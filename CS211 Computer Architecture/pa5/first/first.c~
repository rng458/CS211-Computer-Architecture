#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h> //might delete later

struct cacheBlock {
  int valid;
  unsigned long long accessID;
  unsigned long long tag;
  unsigned long long setInd;
  unsigned long long blockInd;
};

void freeCache(struct cacheBlock** cache, unsigned long long amountOfSets, unsigned long long associativity) {
  for(int i = 0; i < amountOfSets; i++) {
    free(cache[i]);
  }
  free(cache);
}

unsigned long long determineAssoc(char* input, unsigned long long cacheSize, unsigned long long blockSize) {
  if(strcmp("direct", input) == 0) {
    return 1;
  }
  if(strcmp("assoc", input) == 0) {
    return cacheSize/blockSize;
  }
  if(input[5] == ':') {
    char* n = &input[6];
    return atoi(n);
  }
  return 0;
}

int main(int argc, char* argv[argc+1]) {

  unsigned long long cSize = atoi(argv[1]);
  char* cPolicy = argv[3];
  unsigned long long cBlockSize = atoi(argv[4]);
  unsigned long long cAssociativity = determineAssoc(argv[2], cSize, cBlockSize);
  FILE* trace = fopen(argv[5], "r");

  //to check for valid inputs
  //enough arguments?
  if(argc != 6) {
    printf("error\n");
    return EXIT_SUCCESS;
  }
  //powers of 2 test
  int pwr2 = 2;
  int cSizepwr2 = 0;
  int cBlockSizepwr2 = 0;
  while(pwr2 <= cSize || pwr2 <= cBlockSize) {
    if(pwr2 == cSize) {
      cSizepwr2 = 1;
    }
    if(pwr2 == cBlockSize) {
      cBlockSizepwr2 = 1;
    }
    pwr2 = pwr2*2;
  }
  if(!cSizepwr2 || !cBlockSizepwr2) {
    printf("error\n");
    return EXIT_SUCCESS;
  }
  //valid file?
  if(!trace) {
    printf("error\n");
    return EXIT_SUCCESS;
  }

  //malloc a 2d array
  unsigned long long amountOfSets = cSize/(cAssociativity*cBlockSize);
  struct cacheBlock** l1cache = malloc(amountOfSets*sizeof(struct cacheBlock*));
  for(int i = 0; i < amountOfSets; i++) {
    l1cache[i] = malloc(cAssociativity*sizeof(struct cacheBlock));
    for(int j = 0; j < cAssociativity; j++) {
      l1cache[i][j].valid = 0;
    }
  }

  //determining bit lengths
  int amountOfBlockBits = 0 ;
  int amountOfSetBits = 0;
  int blockCounter = cAssociativity;
  int setCounter = amountOfSets;

  while(blockCounter % 2 == 0) {
    amountOfBlockBits++;
    blockCounter = blockCounter/2;
  }
  while(setCounter % 2 == 0) {
    amountOfSetBits++;
    setCounter = setCounter/2;
  }
  
  int amountOfTagBits = 48 - (amountOfBlockBits+amountOfSetBits);
  printf("block bits %d, set bits %d, tag bits %d\n", amountOfBlockBits, amountOfSetBits, amountOfTagBits);
    

  //scan file
  char instruction;
  unsigned long long address;
  while(fscanf(trace,"%c %llx\n", &instruction, &address) != EOF) {
    //masking each part
    unsigned long long tagA =;
    unsigned long long setA =;
    unsigned long long blockA =;
    if(instruction == 'W') {

    }
    else if(instruction == 'R') {

    }
  }

  freeCache(l1cache, amountOfSets, cAssociativity);
  
  //debug
  printf("Here are your inputs: \n");
  printf("Cache size: %llu\n", cSize);
  printf("Cache Associativity: %llu\n", cAssociativity);
  printf("Cache Policy: %s\n", cPolicy);
  printf("Cache Block Size: %llu\n", cBlockSize);
  printf("Trace file name: %s\n", argv[5]);

  return EXIT_SUCCESS;
}
